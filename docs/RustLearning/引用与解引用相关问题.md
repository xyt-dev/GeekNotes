---
title: 引用与解引用相关问题
order: 6
---

# 引用与解引用相关问题

## 临时解引用会不会夺取所有权?

例1:
```rust:no-line-numbers
let arr = vec![String::new(), String::new()];
arr[0]; // Err: cannot move out of a shared reference. move occurs because value has type `String`, which does not implement the `Copy` trait
&arr[0]; // ok
```
理解: \
先说明一下, `arr[0];`相当于`*(arr.index(0));`. 其中`arr.index(0)`返回&String, 而下标访问的语义是访问其中的值, 因此会再进行解引用. \
但问题是`arr[0];`没有移动所有权给其他变量啊? 其实**此处等价于`let _ = *(arr.index(0));`, 语义可以理解为: 将解引用出的`String`类型变量的所有权移动给一个临时变量然后`drop`, 而Rust禁止通过引用转移被引用变量的所有权.** \
而对于`&arr[0];`, 其语义等价于`let _ = &(*(arr.index(0)))`, 右边整体值的类型为&String, 而引用类型都实现了`Copy Trait`, 不用多说. **关键是不要误以为"解引用`*(arr.index(0))`会创建一个临时变量转移原变量所有权", 使用`*`解引用访问的就是原变量!** \
**另外值得说明的是: 虽然编译器可能会将其中的`&*`直接优化掉, 但语义合法性不依赖于编译器优化, 即使没有编译优化也是合法的.**

例2:
```rust:no-line-numbers
let s = Point{x:1.0, y:1.0};
let s1 = &s;
*s1; // Err: cannot move out of `*s1` which is behind a shared reference. move occurs because `*s1` has type `Point`, which does not implement the `Copy` trait.
(*s1).x; // ok
```
原理同上, `s1.x`等价于`(&(*s1)).x`, 其中`(*s1)`不会移动原变量所有权, 而是直接使用解引用出的原变量.

## `.`运算符的行为

### 当实例通过点操作符调用一个方法时, 编译器会按照以下搜索算法查找该方法:
1. 检查类型`T`本身是否实现了该方法, 优先调用.
2. 如果类型`T`本身无法找到方法, 编译器会查找`&T`或`&mut T`是否实现了该方法, 这称为引用方法调用(至多只会进行一阶自动引用, `&mut T`可以匹配`&T`的方法但会优先匹配`&mut T`的方法).
> 注意, 实验表明, 以下两个func优先级相同, 编译器无法判断应该调用哪个函数:
> ```rust
> impl Test1 for A {
>   fn func(&self) {println!("引用调用1")}
> }
> impl Test2 for &A {
>   fn func(self) {println!("引用调用2")}
> }
> // test:
> let a = A {value: 6};
> let ref_a = &a;
> a.func(); // Err: multiple applicable items in scope, multiple `func` found.
> ref_a.func(); // Err: multiple applicable items in scope, multiple `func` found.
> ```
3. 如果类型本身没有实现该方法, 则编译器尝试进行一次解引用(可通过`Deref`或`DerefMut`特征方法), 然后回到步骤1, 这称为解引用方法调用.
4. 若`T`不能被继续解引用, 且`T`是一个定长类型(在编译期类型长度是已知的), 那么编译器也会尝试将`T`从定长类型转为不定长类型, 例如将`[u32; 2]`转为`[u32]`.

## 可变引用的独占性不影响原始指针

`&mut`具有独占性(noalias属性), 而原始指针没有独占性. \
以下代码不能通过:
```rust:no-line-numbers
let mut s = String::from("haha");
let s1 = &mut s;
let s2 = &raw mut s; // Err: cannot borrow `s` as mutable more than once at a time
println!("{s1}");
```
但以下代码却可以通过:
```rust:no-line-numbers
let mut s = String::from("haha");
let s2 = &raw mut s;
let s1 = &mut s;
println!("{}", unsafe{&mut *s2});
```
理解: 创建引用`&mut s`后, **原变量`s`被冻结**, 对原变量`s`的任何借用或所有权移动操作不被允许, 即使`&raw mut s`或`&raw const s`也不被允许; 而先使用`&raw mut s`或`&raw const s`创建原始指针不会影响原变量的借用检查. \
如果先创建了`&mut s`, **此时对于原变量的使用只能基于该引用**, 所以仍可以通过以下方式创建原始指针:
```rust:no-line-numbers
let mut s = String::from("haha");
let s1 = &mut s;
let s2 = s1 as *mut String; // ok
let s3 = &raw mut *s1; // ok
println!("{s1}");
println!("{} {}", unsafe{&mut *s2}, unsafe{&mut *s3});
```

## 对Box的解引用

对Box类型变量的*操作符解引用行为是编译器内部处理的, 会直接取出内部的值同时转移所有权.
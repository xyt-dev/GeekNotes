---
title: 引用与解引用相关问题
order: 6
---

# 引用与解引用相关问题

## `[]`下标访问行为

```rust:no-line-numbers
let arr = vec![String::new(), String::new()];
arr[0]; // move occurs because value has type `String`, which does not implement the `Copy` trait
```

```rust:no-line-numbers
let arr = vec![String::new(), String::new()];
&arr[0]; // ok
```

对该现象的理解: \
`arr[0];`相当于`*(arr.index(0));`. **其中`arr.index(0)`返回&String, 而下标访问的语义是访问其中的值, 因此会再进行解引用.** \
但`arr[0];`没有移动所有权给其他变量啊? 应该是此处**创建了一个临时变量(用于存放表达式`*(arr.index(0))`产生的临时值), 相当于移动数据的所有权给该临时变量, 而编译器不允许通过引用移动其中数据所有权.** \
那么凭什么`&arr[0];`就可以编译通过? deepseek: 对于`&(*(arr.index(0)))`Rust编译器会进行**优化, 令`&`和`*`相互抵消, 从而将其简化为`arr.index(0)`, 即直接返回 `&String`, 这种优化的前提是`&*`的目标变量是`&`修饰的引用类型, 而非实现了`Deref`的类型.**

## `.`运算符的行为

### 当实例通过点操作符调用一个方法时, 编译器会按照以下搜索算法查找该方法:
1. 检查类型`T`本身是否实现了该方法, 优先调用.
2. 如果类型`T`本身无法找到方法, 编译器会查找`&T`或`&mut T`是否实现了该方法, 这称为引用方法调用(至多只会进行一阶自动引用, `&mut T`可以匹配`&T`的方法但会优先匹配`&mut T`的方法).
> 注意, 实验表明, 以下两个func优先级相同, 编译器无法判断应该调用哪个函数:
> ```rust
> impl Test1 for A {
>   fn func(&self) {println!("引用调用1")}
> }
> impl Test2 for &A {
>   fn func(self) {println!("引用调用2")}
> }
> // test:
> let a = A {value: 6};
> let ref_a = &a;
> a.func(); // Err: multiple applicable items in scope, multiple `func` found.
> ref_a.func(); // Err: multiple applicable items in scope, multiple `func` found.
> ```
3. 如果类型本身没有实现该方法, 则编译器尝试进行一次解引用(可通过`Deref`或`DerefMut`特征方法), 然后回到步骤1, 这称为解引用方法调用.
4. 若`T`不能被继续解引用, 且`T`是一个定长类型(在编译期类型长度是已知的), 那么编译器也会尝试将`T`从定长类型转为不定长类型, 例如将`[u32; 2]`转为`[u32]`.

## 可变引用的独占性不影响原始指针

`&mut`具有独占性(noalias属性), 而原始指针没有独占性. \
以下代码不能通过:
```rust:no-line-numbers
let mut s = String::from("haha");
let s1 = &mut s;
let s2 = &raw mut s; // Err: cannot borrow `s` as mutable more than once at a time
println!("{s1}");
```
但以下代码却可以通过:
```rust:no-line-numbers
let mut s = String::from("haha");
let s2 = &raw mut s;
let s1 = &mut s;
println!("{}", unsafe{&mut *s2});
```
理解: 创建引用`&mut s`后, **原变量`s`被冻结**, 对原变量`s`的任何借用或所有权移动操作不被允许, 即使`&raw mut s`或`&raw const s`也不被允许; 而先使用`&raw mut s`或`&raw const s`创建原始指针不会影响原变量的借用检查. \
如果先创建了`&mut s`, **此时对于原变量的使用只能基于该引用**, 所以仍可以通过以下方式创建原始指针:
```rust:no-line-numbers
let mut s = String::from("haha");
let s1 = &mut s;
let s2 = s1 as *mut String; // ok
let s3 = &raw mut *s1; // ok
println!("{s1}");
println!("{} {}", unsafe{&mut *s2}, unsafe{&mut *s3});
```